<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IDV A3 – Five Chart Collection</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Microsoft YaHei", sans-serif; margin: 24px; line-height: 1.5; }
    h1 { font-size: 24px; margin: 0 0 12px; }
    h2 { font-size: 20px; margin: 24px 0 12px; }
    .chart { display: block; max-width: 900px; border: 1px solid #ddd; }
    .tooltip { position: absolute; pointer-events: none; padding: 4px 8px; background:#fff; border:1px solid #ccc; font-size:12px; border-radius: 4px; box-shadow: 0 1px 2px #0001; }
    figure { margin: 16px 0 8px; }
    figcaption { font-size: 13px; color: #555; line-height: 1.45; margin-top: 8px; }
    figcaption strong { color: #333; }
    .divider { margin: 40px 0; border: none; border-top: 1px solid #ccc; }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>

<h1>IDV A3 – Five Chart Collection</h1>

<!-- =================== Chart 1 =================== -->
<h2>Chart 1 – Single Chart Test (Parallelogram Recreation)</h2>
<figure>
  <svg id="chart1" class="chart" width="900" height="300"></svg>
  <figcaption>
    <strong>Figure note.</strong> Chart 1: I askt how to:Implement a light background grid using linear scales.
    Draw each vector as an SVG &lt;path&gt; generated by the arrow() function.
    Animate solid lines with a stroke-draw transition, and fade in dashed lines.
    Automatically color arrowheads with the markerFor(stroke) function.
    Enable hover interaction to highlight a line and display a tooltip showing its label.
    Test Chart 1 independently by calling drawChart1() only.
    Remove arrowheads from solid lines by passing arrow:false.
    Fix dashed lines’ visibility by separating their stroke-dasharray animations.
    Ensure arrowheads match line colors by applying the dynamic markerFor() function.
    Insert the dynamic arrow-color code immediately after creating defs inside drawChart1().
  </figcaption>
</figure>

<hr class="divider" />

<!-- =================== Chart 2 =================== -->
<h2>Chart 2 – Frequency Chart Recreation</h2>
<figure>
  <svg id="chart2" class="chart" width="900" height="300"></svg>
  <figcaption>
    <strong>Figure note.</strong> This area chart recreates the assignment’s “Chart 2” using
    linear interpolation between keypoints and a soft time gate (1985–2022 with 2-year ramps).
    “Vector” is intentionally split into base and extra layers (same hue, different opacity/stroke)
    to visualize overlap. The legend hides the “Vector (extra)” entry to avoid duplication.
  </figcaption>
</figure>

<hr class="divider" />

<!-- =================== Chart 3 =================== -->
<h2>Chart 3 – Pie Chart Recreation</h2>
<figure>
  <svg id="chart3" class="chart" width="900" height="300"></svg>
  <figcaption>
    <strong>Figure note.</strong> For Chart 3, I asked how to: adjust each circle’s radius by modifying the r value in the sets array,
    and reposition the Roman numerals IV, V, VI using pixel offsets with add(mid(...), dx, dy) or nudge(a, b, t, dl, dp) to fine-tune their placement.
    Change the category labels Delete, Replace, Rewrite to absolute coordinates (titleX, titleY) for precise alignment, and update circle colors by editing the color field,
    using dark-blue codes such as #1f77b4, #1f4f8a, or #003f5c as needed. Ensure that const sets is defined only once to prevent redeclaration errors,
    and always declare helper functions like add() and mid() (or nudge()) before using them.
    Finally, check the browser console to verify that no reference or syntax errors occur and confirm all labels render correctly.
  </figcaption>
</figure>

<hr class="divider" />

<!-- =================== Chart 4 =================== -->
<h2>Chart 4 – Bar Chart Recreation</h2>
<figure>
  <svg id="chart4" class="chart" width="900" height="300"></svg>
  <figcaption>
    <strong>Figure note.</strong> For Chart 4, I asked how to: Reproduce the figure in D3.js with animated bar growth and labeled values.
    Match the original design, including the solid yellow bars with gray borders and the dashed-outline bars beside them.
    Add chart details, such as the main title “Cross Validation Accuracy (%)” and model names below the x-axis.
    Solve visual discrepancies—specifically, how to draw the outer rectangular frame around the entire plot area (the “panel border”), since your D3 output lacked it.
    Refine the stroke and crisp edges of each bar to make the style closer to the example figure.
  </figcaption>
</figure>

<hr class="divider" />

<!-- =================== Chart 5 =================== -->
<h2>Chart 5 – Gaussian Curve Recreation</h2>
<figure>
  <svg id="chart5" class="chart" width="900" height="300"></svg>
  <figcaption>
    <strong>Figure note.</strong> Chart 5: I askt how to:Recreate the Gaussian curve chart using D3.js. Adjust the peak positions and widths of the two Gaussian curves by modifying their mean (μ) and standard deviation (σ).
    Control the maximum y-value of each curve using target peak height parameters. Add shaded regions representing different integration areas:
    light gray for the brown curve from xStart to the first dashed line and from the second dashed line to x = 2.5, and dark gray for both curves between
    the two dashed lines. Display background grid lines, two vertical dashed boundaries, and the probability density label vertically along the left y-axis.
    Replace all comments and annotations with English, change the second curve color to brown, and update all interaction and hover tooltips to English as well.
    Add hover interactions that highlight the shaded area and display area values dynamically. Display calculated area values (A₁, A₂) beside each legend item.
    Format the legend text in a mathematical style using p(x, y = 0)·ν(x) and p(x, y = 1)·ν(x) with italic font and bold y.
    Ensure all components—including grid, curves, shading, tooltips, and legend—render correctly and interact smoothly.
  </figcaption>
</figure>

<script>
// =================== Chart 1 Script ===================
function drawChart1() {
  const svg = d3.select("#chart1");
  const W = +svg.attr("width"), H = +svg.attr("height");
  svg.selectAll("*").remove();

  const x = d3.scaleLinear().domain([0, 10]).range([30, W - 20]);
  const y = d3.scaleLinear().domain([0, 6]).range([H - 25, 15]);

  const gx = d3.range(0, 10.0001, 1);
  const gy = d3.range(0, 6.0001, 1);

  svg.append("g").selectAll("line").data(gx).enter().append("line")
    .attr("x1", d => x(d)).attr("x2", d => x(d))
    .attr("y1", y(0)).attr("y2", y(6))
    .attr("stroke", "#9aa4").attr("stroke-width", 1);

  svg.append("g").selectAll("line").data(gy).enter().append("line")
    .attr("y1", d => y(d)).attr("y2", d => y(d))
    .attr("x1", x(0)).attr("x2", x(10))
    .attr("stroke", "#9aa4").attr("stroke-width", 1);

  const defs = svg.append("defs");
  defs.append("marker")
    .attr("id", "arrow").attr("viewBox", "0 0 10 10")
    .attr("refX", 9).attr("refY", 5).attr("markerWidth", 8).attr("markerHeight", 8)
    .attr("orient", "auto-start-reverse")
    .append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");

  const markerCache = new Map();
  function markerFor(color) {
    if (!markerCache.has(color)) {
      const id = `arrow-${color.replace('#','')}`;
      const m = defs.append("marker")
        .attr("id", id)
        .attr("viewBox", "0 0 10 10")
        .attr("refX", 9).attr("refY", 5)
        .attr("markerWidth", 8).attr("markerHeight", 8)
        .attr("orient", "auto-start-reverse");
      m.append("path").attr("d","M 0 0 L 10 5 L 0 10 z").attr("fill", color).attr("stroke", color);
      markerCache.set(color, id);
    }
    return `url(#${markerCache.get(color)})`;
  }

  const P = {
    ea1: [7, 5], ea2: [4, 5], eb1: [4, 3.0], eb2: [1, 3.0],
  };

  function arrow(from, to, {stroke, width, dash, arrow=true}) {
    const path = svg.append("path")
      .attr("d", d3.line()([[x(from[0]), y(from[1])],[x(to[0]), y(to[1])]]))
      .attr("fill","none")
      .attr("stroke", stroke)
      .attr("stroke-width", width)
      .attr("opacity", 0.95);

    if (arrow) path.attr("marker-end", markerFor(stroke));

    if (dash) {
      path.attr("stroke-dasharray", dash)
          .attr("opacity", 0)
          .transition().duration(700).attr("opacity", 0.95);
    } else {
      const L = path.node().getTotalLength();
      path.attr("stroke-dasharray", `${L} ${L}`).attr("stroke-dashoffset", L)
          .transition().duration(900).ease(d3.easeCubicOut)
          .attr("stroke-dashoffset", 0);
    }
    return path;
  }

  const v1 = arrow(P.eb1, P.ea1, {stroke:"#222", width:2, arrow:false});
  const v2 = arrow(P.eb1, P.eb2, {stroke:"#222", width:2, arrow:false});
  const v5 = arrow(P.eb2, P.ea2, {stroke:"#222", width:2, arrow:false});
  const v6 = arrow(P.ea1, P.ea2, {stroke:"#222", width:2, arrow:false});

  const v3 = arrow(P.ea1, P.eb2, {stroke:"#d73c2c", width:2, dash:"6,6"});
  const v4 = arrow(P.ea2, P.eb1, {stroke:"#e88c2a", width:2, dash:"6,6"});

  const pts = [
    {id:"e^α₁", p:P.ea1}, {id:"e^α₂", p:P.ea2},
    {id:"e^β₁", p:P.eb1}, {id:"e^β₂", p:P.eb2},
  ];
  svg.selectAll("circle.pt").data(pts).enter().append("circle")
    .attr("class","pt").attr("cx", d=>x(d.p[0])).attr("cy", d=>y(d.p[1]))
    .attr("r", 3.5).attr("fill","#0a0");

  const label = svg.selectAll("text.lab").data(pts).enter().append("text")
    .attr("class","lab").attr("x", d=>x(d.p[0])+6).attr("y", d=>y(d.p[1])-6)
    .attr("font-style","italic").attr("font-size", 18).attr("fill","#222");

  label.each(function(d){
    const t = d3.select(this);
    t.text("e");
    t.append("tspan").text(d.id.includes("α") ? "α" : "β")
      .attr("baseline-shift","super").attr("font-size", 14);
    t.append("tspan").text(d.id.slice(-1))
      .attr("baseline-shift","sub").attr("font-size", 16).attr("font-style","normal");
  });

  const vectors = [
    {name:"line eβ₁–eα₁", path:v1},
    {name:"line eβ₂–eα₂", path:v2},
    {name:"line eα₁–eβ₂", path:v3},
    {name:"line eα₂–eβ₁", path:v4},
    {name:"line eβ₂–eα₂", path:v5},
    {name:"line eα₁–eα₂", path:v6},
  ];
  const tip = d3.select("body").append("div").attr("class","tooltip").style("display","none");

  vectors.forEach(v => {
    v.path.on("mousemove", (ev) => {
        d3.select(ev.currentTarget).attr("stroke-width", 3.4);
        tip.style("display","block")
           .style("left", (ev.pageX+10)+"px").style("top",(ev.pageY-18)+"px")
           .text(v.name);
      })
      .on("mouseout", (ev) => {
        const isDashed = d3.select(ev.currentTarget).attr("stroke-dasharray");
        d3.select(ev.currentTarget).attr("stroke-width", isDashed ? 2 : 2.2);
        tip.style("display","none");
      });
  });
}

// =================== Chart 2 Script ===================
function drawChart2() {
  const svg = d3.select("#chart2");
  const W = +svg.attr("width"), H = +svg.attr("height");
  svg.selectAll("*").remove();

  const years = d3.range(1980, 2025, 1);
  const x = d3.scaleLinear().domain([1980, 2025]).range([50, W-20]);
  const y = d3.scaleLinear().domain([0, 10]).range([H-30, 20]);

  svg.append("g")
     .attr("transform", `translate(0,${H-30})`)
     .call(d3.axisBottom(x)
        .tickValues(d3.range(1980, 2025, 5))
        .tickFormat(d3.format("d")));

  const yAxisG = svg.append("g")
     .attr("transform", `translate(50,0)`)
     .call(d3.axisLeft(y).ticks(5));

  yAxisG.append("text")
    .attr("transform", `translate(-32, ${H/2}) rotate(-90)`) 
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .attr("font-size", 14)
    .attr("fill", "#333")
    .text("Frequency");

  function seriesFromKeypoints(keys, years) {
    const ys = [];
    for (let i = 0; i < keys.length - 1; i++) {
      const a = keys[i], b = keys[i+1];
      for (let yy = a.year; yy <= b.year; yy++) {
        const t = (yy - a.year) / (b.year - a.year);
        ys.push({ year: yy, freq: a.value*(1 - t) + b.value*t });
      }
    }
    const filled = new Map(ys.map(p => [p.year, p.freq]));
    return years.map(y => ({year: y, freq: filled.get(y) ?? 0}));
  }
  function softGate(yval, a=1985, b=2022, ramp=2){
    if (yval < a - ramp) return 0;
    if (yval < a)        return (yval - (a - ramp)) / ramp;
    if (yval <= b)       return 1;
    if (yval <= b + ramp)return 1 - (yval - b) / ramp;
    return 0;
  }

  const specs = [
    { name: "Set model", color: "#76c7b7",
      keys: [
        {year:1985, value:0.0}, {year:1986, value:1.0}, {year:1987, value:0.0},
        {year:2000, value:0.0}, {year:2001, value:1.0}, {year:2002, value:0.0},
        {year:2004, value:2.0}, {year:2005, value:0.0},
        {year:2010, value:0.0}
      ]
    },
    { name: "Sequence model", color: "#d1a372",
      keys: [
        {year:1989, value:0.0}, {year:1990, value:1.0}, {year:1991, value:0.0},{year:1992, value:1.0}, {year:1993, value:0.0},
        {year:1995, value:0.0}, {year:1996, value:1.0}, {year:1997, value:1.0},{year:1998, value:0.0},
        {year:2003, value:0.0}, {year:2004, value:1.0}, {year:2005, value:0.0},
        {year:2006, value:2.0}, {year:2007, value:0.0},
        {year:2015, value:0.0}, {year:2016, value:1.0}, {year:2017, value:0.0},
        {year:2018, value:1.0}, {year:2019, value:1.0},{year:2020, value:0.0}
      ]
    },
    { name: "End-to-end", color: "#de709d",
      keys: [
        {year:1994, value:0.0}, {year:1995, value:1.0}, {year:1996, value:0.0},
        {year:1997, value:1.0}, {year:1998, value:1.0},{year:1999, value:0.0},
        {year:2002, value:0.0}, {year:2003, value:1.0},{year:2004, value:0.0},
        {year:2006, value:0.0}, {year:2007, value:2.0},{year:2008, value:0.0},
        {year:2010, value:0.0}, {year:2011, value:0.5},{year:2012, value:4.0},{year:2013, value:2.0},{year:2014, value:3.0},
        {year:2015, value:4.0}, {year:2016, value:3.0},{year:2017, value:3.5},{year:2018, value:3.0},{year:2019, value:9.0},
        {year:2020, value:2.0}, {year:2021, value:0.0}
      ]
    }
  ];

  const vectorBaseKeys = [
    {year:1987, value:0.0}, {year:1988, value:1.0}, {year:1989, value:0.0},
    {year:1998, value:0.0}, {year:1999, value:1.0}, {year:2000, value:0.0},
    {year:2001, value:0.0}, {year:2003, value:2.0}, {year:2004, value:0.0},
    {year:2005, value:0.0}, {year:2006, value:1.0},{year:2008, value:1.0},{year:2009, value:2.0},{year:2010, value:0.0},
    {year:2011, value:0.0}, {year:2012, value:2.0},{year:2013, value:3.0},{year:2014, value:4.0},{year:2015, value:1.0},{year:2016, value:0.0}
  ];
  const vectorExtraPeakKeys = [
    {year:2014, value:0.0},
    {year:2015, value:1.0},
    {year:2016, value:2.0},
    {year:2017, value:4.0},
    {year:2018, value:3.0},
    {year:2019, value:0.0}
  ];

  let vectorBaseVals  = seriesFromKeypoints(vectorBaseKeys, years)
                        .map(d => ({year:d.year, freq: d.freq * softGate(d.year,1985,2022,2)}));
  let vectorExtraVals = seriesFromKeypoints(vectorExtraPeakKeys, years)
                        .map(d => ({year:d.year, freq: d.freq * softGate(d.year,1985,2022,2)}));

  const data = [
    { name: "Set model",      color: "#76c7b7",
      values: seriesFromKeypoints(specs[0].keys, years).map(d => ({year:d.year, freq:d.freq * softGate(d.year,1985,2022,2)})) },
    { name: "Sequence model", color: "#d1a372",
      values: seriesFromKeypoints(specs[1].keys, years).map(d => ({year:d.year, freq:d.freq * softGate(d.year,1985,2022,2)})) },

    { name: "Vector",  color: "#9b8dc2", values: vectorBaseVals, _fillOpacity: 0.45, _stroke: "#6d63a8" },
    { name: "Vector (extra)", color: "#7a6fb5", values: vectorExtraVals, _fillOpacity: 0.65, _stroke: "#4f468f" },

    { name: "End-to-end",     color: "#0033A0",
      values: seriesFromKeypoints(specs[2].keys, years).map(d => ({year:d.year, freq:d.freq * softGate(d.year,1985,2022,2)})) }
  ];

  const area = d3.area()
    .x(d => x(d.year))
    .y0(y(0))
    .y1(d => y(d.freq))
    .curve(d3.curveMonotoneX);

  const tip = d3.select(".tooltip").empty()
    ? d3.select("body").append("div").attr("class","tooltip").style("display","none")
    : d3.select(".tooltip");

  const groups = svg.selectAll(".layer").data(data).enter().append("g").attr("class","layer");

  groups.append("path")
    .attr("fill", d => d.color)
    .attr("fill-opacity", d => d._fillOpacity ?? 0.6)
    .attr("stroke", d => d._stroke ?? "none")
    .attr("stroke-width", d => d._stroke ? 1.5 : 0)
    .attr("d", d => area(d.values.map(v => ({year:v.year, freq:0}))))
    .transition().duration(1200)
    .attr("d", d => area(d.values));

  groups.on("mousemove", (event, d) => {
      groups.transition().duration(100).attr("opacity", g => g===d ? 1 : 0.3);
      tip.style("display","block")
         .style("left",(event.pageX+10)+"px").style("top",(event.pageY-20)+"px")
         .text(d.name);
    })
    .on("mouseout", () => {
      groups.transition().duration(200).attr("opacity", 1);
      tip.style("display","none");
    });

  const legendData = data.filter(d => !d.name.includes("Vector (extra)"));
  const legend = svg.append("g").attr("transform", `translate(${W-200},28)`);

  legend.selectAll("rect").data(legendData).enter().append("rect")
    .attr("x",0).attr("y",(d,i)=>i*22).attr("width",15).attr("height",15)
    .attr("fill",d=>d.color).attr("fill-opacity",d=>d._fillOpacity ?? 0.6)
    .attr("stroke", d => d._stroke ?? "none").attr("stroke-width", d => d._stroke ? 1.5 : 0);

  legend.selectAll("text").data(legendData).enter().append("text")
    .attr("x",20).attr("y",(d,i)=>i*22+12).attr("font-size",13).text(d=>d.name);
}

// =================== Chart 3 Script ===================
function drawChart3() {
  const svg = d3.select("#chart3");
  const W = +svg.attr("width"), H = +svg.attr("height");
  svg.selectAll("*").remove();

  const sets = [
    { id:"Delete",  cx:290, cy:200, r:100, color:"#1f77b4", titleX:150, titleY:200 },
    { id:"Replace", cx:360, cy:100, r:100, color:"#b69aa3", titleX:240, titleY: 28 },
    { id:"Rewrite", cx:420, cy:200, r:100, color:"#e7cf7b", titleX:560, titleY:200 },
  ];

  const g = svg.append("g");

  g.selectAll("text.title").data(sets).enter().append("text")
    .attr("class","title")
    .attr("x", d => d.titleX ?? d.cx)
    .attr("y", d => d.titleY ?? (d.cy - d.r - 18))
    .attr("text-anchor","middle")
    .attr("font-size",18)
    .text(d => d.id);

  const tip = d3.select("body").append("div")
    .attr("class","tooltip").style("display","none");

  g.selectAll("circle.set").data(sets).enter().append("circle")
    .attr("class","set")
    .attr("cx", d => d.cx).attr("cy", d => d.cy)
    .attr("r", 0)
    .attr("fill", d => d.color)
    .attr("fill-opacity", 0.55)
    .attr("stroke", "#000").attr("stroke-opacity", 0.25)
    .transition().duration(900)
    .attr("r", d => d.r);

  g.selectAll("circle.set")
    .on("mousemove", (ev, d) => {
      g.selectAll("circle.set").attr("opacity", s => (s===d ? 1 : 0.25));
      tip.style("display","block")
         .style("left",(ev.pageX+10)+"px").style("top",(ev.pageY-20)+"px")
         .text(d.id);
    })
    .on("mouseout", () => {
      g.selectAll("circle.set").attr("opacity", 1);
      tip.style("display","none");
    });

  const add = (p, dx=0, dy=0) => [p[0] + dx, p[1] + dy];
  const C = Object.fromEntries(sets.map(s => [s.id, [s.cx, s.cy]]));
  const mid = (a,b,t=0.5)=>[a[0]*(1-t)+b[0]*t, a[1]*(1-t)+b[1]*t];

  const labels = [
    {txt:"I",   pos:[C.Delete[0]-70,  C.Delete[1]+40]},
    {txt:"II",  pos:[C.Replace[0],    C.Replace[1]-30]},
    {txt:"III", pos:[C.Rewrite[0]+60, C.Rewrite[1]+20]},
    {txt:"IV",  pos:add(mid(C.Delete,  C.Replace, 0.50),-12,0)},
    {txt:"V",   pos:add(mid(C.Replace, C.Rewrite, 0.50),+10,0)},
    {txt:"VI",  pos:add(mid(C.Delete,  C.Rewrite, 0.50),0,+40)},
    {txt:"VII", pos: [(C.Delete[0]+C.Replace[0]+C.Rewrite[0])/3,
                      (C.Delete[1]+C.Replace[1]+C.Rewrite[1])/3]},
  ];

  g.selectAll("text.region").data(labels).enter().append("text")
    .attr("class","region")
    .attr("x", d=>d.pos[0]).attr("y", d=>d.pos[1])
    .attr("font-size",22).attr("font-weight","600")
    .attr("text-anchor","middle")
    .text(d=>d.txt);
}

// =================== Chart 4 Script ===================
function drawChart4() {
  const svg = d3.select("#chart4");
  const W = +svg.attr("width"), H = +svg.attr("height");
  svg.selectAll("*").remove();

  const data = [
    { model: "BERT", acc1: 74.4, acc2: 64.8 },
    { model: "RoBERTa", acc1: 81.9, acc2: 65.5 },
    { model: "BART", acc1: 73.1, acc2: 63.5 },
  ];

  const margin = {top: 50, right: 30, bottom: 40, left: 40};
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;

  const x0 = d3.scaleBand().domain(data.map(d => d.model)).range([0, innerW]).padding(0.25);
  const x1 = d3.scaleBand().domain(["acc1", "acc2"]).range([0, x0.bandwidth()]).padding(0.2);
  const y = d3.scaleLinear().domain([0, 100]).range([innerH, 0]);

  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  g.append("g").attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x0).tickSize(0)).selectAll("text").attr("font-size",13);
  g.append("g").call(d3.axisLeft(y).ticks(5));

  svg.append("text")
    .attr("x", W/2).attr("y", 65)
    .attr("text-anchor","middle").attr("font-size",12).attr("font-weight","600")
    .text("Cross Validation Accuracy (%)");

  const tooltip = d3.select("body").append("div").attr("class","tooltip").style("display","none");

  const bars = g.selectAll("g.barGroup").data(data).enter().append("g")
    .attr("class","barGroup").attr("transform", d => `translate(${x0(d.model)},0)`);

  bars.append("rect")
    .attr("x", d => x1("acc1"))
    .attr("y", innerH)
    .attr("width", x1.bandwidth())
    .attr("height", 0)
    .attr("fill", "#1f77b4")
    .attr("stroke", "#555")
    .transition().duration(900)
    .attr("y", d => y(d.acc1))
    .attr("height", d => innerH - y(d.acc1));

  bars.append("rect")
    .attr("x", d => x1("acc2"))
    .attr("y", innerH)
    .attr("width", x1.bandwidth())
    .attr("height", 0)
    .attr("fill", "none")
    .attr("stroke", "#caa94a")
    .attr("stroke-width", 2)
    .attr("stroke-dasharray", "6,4")
    .transition().duration(1000)
    .attr("y", d => y(d.acc2))
    .attr("height", d => innerH - y(d.acc2));

  bars.selectAll("text.val").data(d => [
    {x:"acc1", val:d.acc1}, {x:"acc2", val:d.acc2}
  ]).enter().append("text")
    .attr("class","val")
    .attr("x", d => x1(d.x) + x1.bandwidth()/2)
    .attr("y", innerH)
    .attr("text-anchor","middle")
    .attr("font-size",12)
    .attr("fill","#333")
    .transition().delay(900).duration(300)
    .attr("y", d => y(d.val) - 4)
    .text(d => d.val.toFixed(1));

  g.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", innerW)
    .attr("height", innerH)
    .attr("fill", "none")
    .attr("stroke", "#b69aa3")
    .attr("stroke-width", 1)
    .attr("vector-effect", "non-scaling-stroke");
  g.selectAll(".domain").attr("stroke", "none");

  bars.on("mousemove", (ev, d) => {
      tooltip.style("display","block")
             .style("left",(ev.pageX+10)+"px")
             .style("top",(ev.pageY-18)+"px")
             .text(`${d.model}: ${d.acc1.toFixed(1)} / ${d.acc2.toFixed(1)}`);
      d3.select(ev.currentTarget).selectAll("rect")
        .attr("stroke-width",3);
    })
    .on("mouseout", (ev) => {
      tooltip.style("display","none");
      d3.select(ev.currentTarget).selectAll("rect")
        .attr("stroke-width",2);
    });
}

// =================== Chart 5 Script ===================
function drawChart5() {
  const svg = d3.select("#chart5");
  const W = +svg.attr("width"), H = +svg.attr("height");
  svg.selectAll("*").remove();

  const CFG = {
    mu0: 0.6,  sigma0: 0.6,
    mu1: 2.0,  sigma1: 0.7,
    targetPeak0: 0.25,
    targetPeak1: 0.30,
    color0: "#e6b74f",
    color1: "#8B4513",
    label0: "p(x, y = 0) · ν(x)",
    label1: "p(x, y = 1) · ν(x)",
    yLabel: "Probability Density",
    xStartBrown: -0.5,
    dashA: 1.1,
    dashB: 1.7,
    lightFill: 0.35,
    darkFill: 0.6,
    xDomain: [-2, 5],
    yMax: 0.35
  };

  const margin = {top: 40, right: 20, bottom: 42, left: 56};
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;
  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  const TWO_PI = 2*Math.PI;
  const basePdf = (mu, sigma) => x =>
    (1/(sigma*Math.sqrt(TWO_PI))) * Math.exp(-0.5 * ((x-mu)/sigma)**2);

  const amp0 = (CFG.targetPeak0 ?? 1) * CFG.sigma0 * Math.sqrt(TWO_PI);
  const amp1 = (CFG.targetPeak1 ?? 1) * CFG.sigma1 * Math.sqrt(TWO_PI);
  const p0 = x => amp0 * basePdf(CFG.mu0, CFG.sigma0)(x);
  const p1 = x => amp1 * basePdf(CFG.mu1, CFG.sigma1)(x);

  const xs = d3.range(CFG.xDomain[0], CFG.xDomain[1] + 1e-6, 0.01);
  const curve0 = xs.map(t => ({x:t, y:p0(t)}));
  const curve1 = xs.map(t => ({x:t, y:p1(t)}));

  const yMax = CFG.yMax ?? 1.15 * Math.max(
    d3.max(curve0, d => d.y),
    d3.max(curve1, d => d.y)
  );

  const x = d3.scaleLinear().domain(CFG.xDomain).range([0, innerW]);
  const y = d3.scaleLinear().domain([0, yMax]).range([innerH, 0]);

  g.append("g").attr("class","x grid")
    .attr("transform", `translate(0,${innerH})`)
    .call(d3.axisBottom(x).ticks(10).tickSize(-innerH).tickFormat(""))
    .selectAll("line").attr("stroke","#ddd");
  g.append("g").attr("class","y grid")
    .call(d3.axisLeft(y).ticks(7).tickSize(-innerW).tickFormat(""))
    .selectAll("line").attr("stroke","#ddd");

  g.append("g").attr("transform", `translate(0,${innerH})`).call(d3.axisBottom(x));
  g.append("g").call(d3.axisLeft(y));
  svg.append("text").attr("x", W/2).attr("y", H-6).attr("text-anchor","middle").text("x");
  svg.append("text")
    .attr("transform", `translate(${margin.left - 45}, ${H/2}) rotate(-90)`)
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .attr("font-size", 10)
    .text(CFG.yLabel);

  g.append("rect").attr("x",0).attr("y",0).attr("width",innerW).attr("height",innerH)
    .attr("fill","none").attr("stroke","#555").attr("stroke-width",1.2);

  const tooltip = d3.select("body").append("div").attr("class","tooltip").style("display","none");

  const area = d3.area().x(d => x(d.x)).y0(y(0)).y1(d => y(d.y)).curve(d3.curveMonotoneX);
  const line = d3.line().x(d => x(d.x)).y(d => y(d.y)).curve(d3.curveMonotoneX);

  const xRight = Math.min(2.5, CFG.xDomain[1]);
  const yellowRight = xs.filter(t => t >= CFG.dashB && t <= xRight).map(t => ({x:t, y:p0(t)}));
  const brownLeft   = xs.filter(t => t >= CFG.xStartBrown && t <= CFG.dashA).map(t => ({x:t, y:p1(t)}));
  const yellowMid   = xs.filter(t => t >= CFG.dashA && t <= CFG.dashB).map(t => ({x:t, y:p0(t)}));
  const brownMid    = xs.filter(t => t >= CFG.dashA && t <= CFG.dashB).map(t => ({x:t, y:p1(t)}));

  function trapz(data){
    if (!data || data.length < 2) return 0;
    let s = 0;
    for (let i = 1; i < data.length; i++) {
      const dx = data[i].x - data[i-1].x;
      s += 0.5 * (data[i-1].y + data[i].y) * dx;
    }
    return s;
  }
  const A_brownLeft   = trapz(brownLeft);
  const A_yellowMid   = trapz(yellowMid);
  const A_brownMid    = trapz(brownMid);
  const A_yellowRight = trapz(yellowRight);

  const regions = [
    {key: "brownLeft",  data: brownLeft,  fill: "#aaa", opacity: CFG.lightFill, label: "Brown curve: xStart→dashA",  A: A_brownLeft},
    {key: "yellowMid",  data: yellowMid,  fill: "#666", opacity: CFG.darkFill,  label: "Yellow curve: dashA→dashB",  A: A_yellowMid},
    {key: "brownMid",   data: brownMid,   fill: "#666", opacity: CFG.darkFill,  label: "Brown curve: dashA→dashB",   A: A_brownMid},
    {key: "yellowRight",data: yellowRight,fill: "#aaa", opacity: CFG.lightFill, label: "Yellow curve: dashB→2.5",    A: A_yellowRight},
  ];

  g.selectAll("path.region")
    .data(regions)
    .enter()
    .append("path")
    .attr("class","region")
    .attr("d", d => area(d.data))
    .attr("fill", d => d.fill)
    .attr("fill-opacity", d => d.opacity)
    .style("cursor","crosshair")
    .on("mousemove", (event, d) => {
      d3.select(event.currentTarget).attr("fill-opacity", Math.min(1, d.opacity + 0.25));
      tooltip.style("display","block")
        .style("left", (event.pageX + 12) + "px")
        .style("top",  (event.pageY - 18) + "px")
        .text(`${d.label} · Area = ${d.A.toFixed(3)}`);
    })
    .on("mouseout", (event, d) => {
      d3.select(event.currentTarget).attr("fill-opacity", d.opacity);
      tooltip.style("display","none");
    });

  ["dashA","dashB"].forEach(k=>{
    g.append("line")
      .attr("x1", x(CFG[k])).attr("x2", x(CFG[k]))
      .attr("y1", y(0)).attr("y2", y(yMax))
      .attr("stroke","#333").attr("stroke-width",1.5)
      .attr("stroke-dasharray","6,6").attr("opacity",0.8);
  });

  g.append("path").attr("d", line(curve0)).attr("fill","none").attr("stroke", CFG.color0).attr("stroke-width", 2.5);
  g.append("path").attr("d", line(curve1)).attr("fill","none").attr("stroke", CFG.color1).attr("stroke-width", 2.5);

  const legendItems = [
    {color: CFG.color0, yval: 0, areaText: `A1=${A_yellowMid.toFixed(3)}, A2=${A_yellowRight.toFixed(3)}`},
    {color: CFG.color1, yval: 1, areaText: `A1=${A_brownLeft.toFixed(3)}, A2=${A_brownMid.toFixed(3)}`},
  ];

  const legend = svg.append("g").attr("transform", `translate(${W-260},${margin.top-1})`);

  const rows = legend.selectAll("g.row")
    .data(legendItems)
    .enter()
    .append("g")
    .attr("class","row")
    .attr("transform", (d,i)=>`translate(0,${i*24})`);

  rows.append("line")
    .attr("x1",0).attr("x2",24).attr("y1",12).attr("y2",12)
    .attr("stroke", d=>d.color).attr("stroke-width",3);

  rows.each(function(d){
    const t = d3.select(this).append("text")
      .attr("x", 30).attr("y", 16);
    t.append("tspan").attr("font-style","italic").text("p(x, ");
    t.append("tspan").attr("font-style","italic").attr("font-weight","bold").text("y");
    t.append("tspan").attr("font-style","italic").text(` = ${d.yval}) · ν(x)`);
  });

  const tooltip2 = tooltip; // reuse
  rows.on("mousemove", (event, d) => {
      tooltip2.style("display","block")
        .style("left",(event.pageX+12)+"px")
        .style("top",(event.pageY-18)+"px")
        .text(`Areas — ${d.areaText}`);
    })
    .on("mouseout", () => tooltip2.style("display","none"));
}

// ===== Call all charts on load =====
drawChart1();
drawChart2();
drawChart3();
drawChart4();
drawChart5();
</script>

</body>
</html>

